# OPTIONS

set cursorpreviewfmt "\033[7;2m"
#set drawbox
set icons
set ifs "\n"
set incsearch true
set number
#set previewer ~/.config/lf/preview
set promptfmt "\033[34;1m%d\033[0m\033[1m%f\033[0m"
set relativenumber
set scrolloff 4
set shell bash
set shellopts '-euo pipefail'
set watch true

# COMMANDS

cmd open &{{
  case $(file --mime-type -Lb $f) in
    text/*) lf -remote "send $id \$$EDITOR \$fx" ;;
    *)
      for f in $fx; do
        $OPENER $f > /dev/null 2> /dev/null &
      done
      ;;
  esac
}}

# trash
cmd trash ${{
  set -f
  if which trash &> /dev/null; then
    trash-put -- $fx
  elif which gio &> /dev/null; then
    gio trash -- $fx
  else
    mkdir -p ~/.trash
    mv -t ~/.trash -- $fx
  fi
}}

cmd delete %{{
  set -f
  read -n 1 -p "delete '$fx'?[y/n]" ans
  [[ $ans = "y" ]] && rm -rf $fx
}}

cmd mkdir %{{
  printf "Directory name: "
  read ans
  mkdir -p -- $ans
}}

cmd sudomkdir %{{
  printf "Directory name: "
  read ans
  sudo mkdir -p -- $ans
}}

cmd mkdirenter %{{
  printf "Directory name: "
  read ans
  mkdir -p -- $ans
  cd -- $ans
}}

cmd sudomkdirenter %{{
  printf "Directory name: "
  read ans
  sudo mkdir -p -- $ans
  cd -- $ans
}}

cmd touch %{{
  printf "File name: "
  read ans
  touch $ans
}}

cmd sudotouch %{{
  printf "File name: "
  read ans
  touch $ans
}}

cmd edit %{{
  printf "File name: "
  read ans
  $EDITOR $ans
}}

cmd sudoedit %{{
  printf "File name: "
  read ans
  sudoedit $EDITOR $ans
}}

cmd extract ${{
  set -f
  case $f in
    *.tar.bz|*.tar.bz2|*.tbz|*.tbz2)  tar xjvf $f;;
    *.tar.gz|*.tgz)                   tar xzvf $f;;
    *.tar.xz|*.txz)                   tar xJvf $f;;
    *.zip)                            unzip $f;;
    *.rar)                            unrar x $f;;
    *.7z)                             7z x $f;;
  esac
}}

# cmd zip %zip -r "$f" "$f"
# cmd tar %tar cvf "$f.tar" "$f"
cmd targz %tar cvzf "$f.tar.gz" "$f"
cmd tarbz2 %tar cjvf "$f. tar.bz2" "$f"

# compress current file or selected files with tar and gunzip
cmd tar ${{
  set -f
  mkdir $1
  cp -r $fx $1
  tar czf $1.tar.gz $1
  rm -rf $1
}}

# compress current file or selected files with zip
cmd zip ${{
  set -f
  mkdir $1
  cp -r $fx $1
  zip -r $1.zip $1
  rm -rf $1
}}

# quick navigation
cmd z %{{
    result="$(zoxide query --exclude "$PWD" "$@" | sed 's/\\/\\\\/g;s/"/\\"/g')"
    lf -remote "send $id cd \"$result\""
}}
cmd zi ${{
    result="$(zoxide query -i | sed 's/\\/\\\\/g;s/"/\\"/g')"
    lf -remote "send $id cd \"$result\""
}}
cmd fzf_jump ${{
    res="$(find . -maxdepth 1 | fzf --reverse --header="Jump to location")"
    if [ -n "$res" ]; then
        if [ -d "$res" ]; then
            cmd="cd"
        else
            cmd="select"
        fi
        res="$(printf '%s' "$res" | sed 's/\\/\\\\/g;s/"/\\"/g')"
        lf -remote "send $id $cmd \"$res\""
    fi
}}
cmd fzf_search ${{
    cmd="rg --column --line-number --no-heading --color=always --smart-case"
    fzf --ansi --disabled --layout=reverse --header="Search in files" --delimiter=: \
        --bind="start:reload([ -n {q} ] && $cmd -- {q} || true)" \
        --bind="change:reload([ -n {q} ] && $cmd -- {q} || true)" \
        --bind='enter:become(lf -remote "send $id select \"$(printf "%s" {1} | sed '\''s/\\/\\\\/g;s/"/\\"/g'\'')\"")' \
        --preview='cat -- {1}' # Use your favorite previewer here (bat, source-highlight, etc.), for example:
        #--preview-window='+{2}-/2' \
        #--preview='bat --color=always --highlight-line={2} -- {1}'
        # Alternatively you can even use the same previewer you've configured for lf
        #--preview='~/.config/lf/cleaner; ~/.config/lf/previewer {1} "$FZF_PREVIEW_COLUMNS" "$FZF_PREVIEW_LINES" "$FZF_PREVIEW_LEFT" "$FZF_PREVIEW_TOP"'
}}
cmd on-cd &{{
    zoxide add "$PWD"
}}

# lf doc
cmd doc $lf -doc | PAGER=less bat -p

# MAPPINGS

map ~ doc

# define a custom 'rename' command without prompt for overwrite
# cmd rename %[ -e $1 ] && printf "file exists" || mv $f $1
# map r push :rename<space>

# show the result of execution of previous commands
map ` !true

# execute current file (must be executable)
# map x $$f
# map X !$f

# dedicated keys for file opener actions
map o &mimeopen $f
map O $mimeopen --ask $f

# reload configuration
map R :source ~/.config/lf/lfrc; echo "Reloaded config"

# shorcuts
map gc cd ~/.config
map gd cd ~/downloads
map gD cd ~/documents

# pager
map i $PAGER=less bat --paging=always $f

map "'"
map '"'
map ,
map a
map e
map m
map za
map zh
map zn
map zr
map zs
map zt

# basic functions
map . set hidden!
map <esc> quit
map D delete
map aD mkdirenter
map ad mkdir
map ae edit
map af touch
map asD sudomkdirenter
map asd sudomkdir
map ase sudoedit
map asf sudotouch
map d trash $f
map p paste
map x cut
map y copy

# file openers
map ee $$EDITOR "$f"
map es $sudo $EDITOR "$f"

# file info
map ,a set info size:time
map ,h set hidden!
map ,n set info
map ,r set reverse!
map ,s set info size
map ,t set info time

# archive mappings
map Ab tarbz2
map Ag targz
map At tar
map Au unarchive
map Az zip

# directory jumping
map zf :fzf_jump
map zi push :zi<space>
map zr :fzf_search
map zz push :z<space>

# make sure trash folder exists
%mkdir -p ~/.trash

# git

# A couple of useful Git commands that can be run directly from LF if you're in a git project
# cmd git_branch ${{
#   git branch | fzf | xargs git checkout
#   pwd_shell="$(pwd | sed 's/\\/\\\\/g;s/"/\\"/g')"
#   lf -remote "send $id updir; cd \"$pwd_shell\""
# }}
# map gb :git_branch
# map gp $clear; git pull --rebase || true; echo "press ENTER"; read ENTER
# map gs $clear; git status; echo "press ENTER"; read ENTER
# map gl $clear; git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit

# An example `on-load` command to show the git status of files inside the info column
# set info custom

cmd on-load &{{
  cd "$(dirname "$1")" || exit 1
  [ "$(git rev-parse --is-inside-git-dir 2>/dev/null)" = false ] || exit 0

  cmds=""

  for file in "$@"; do
    case "$file" in
      */.git|*/.git/*) continue;;
    esac

    status=$(git status --porcelain --ignored -- "$file" | cut -c1-2 | head -n1)

    if [ -n "$status" ]; then
      cmds="${cmds}addcustominfo ${file} \"$status\"; "
    else
      cmds="${cmds}addcustominfo ${file} ''; "
    fi
  done

  lf -remote "send $id :$cmds"
}}

# An example `on-cd` command to show some git related information inside your prompt
cmd on-cd &{{
  # display git repository status in your prompt
  source /usr/share/git/completion/git-prompt.sh
  GIT_PS1_SHOWDIRTYSTATE=auto
  GIT_PS1_SHOWSTASHSTATE=auto
  GIT_PS1_SHOWUNTRACKEDFILES=auto
  GIT_PS1_SHOWUPSTREAM=auto
  GIT_PS1_COMPRESSSPARSESTATE=auto
  git="$(__git_ps1 " [GIT BRANCH:> %s]")" || true
  fmt="\033[32;1m%u@%h\033[0m:\033[34;1m%w\033[0m\033[33;1m$git\033[0m"
  lf -remote "send $id set promptfmt \"$fmt\""
}}

# Another example `on-cd` command to show some git, mercury and subversion
# repository information only on parent directory. This will clear prompt when
# outside of parent directory of a git repository
# cmd on-cd &{{
#   # display repository status in your prompt
#   if [ -d .git ] || [ -f .git ]; then
#     branch="$(git branch --show-current 2>/dev/null)" || true
#     remote="$(git config --get "branch.$branch.remote" 2>/dev/null)" || true
#     url="$(git remote get-url "$remote" 2>/dev/null)" || true
#     fmt="\033[32;1m%u@%h\033[0m:\033[34;1m%w\033[0m\033[33;1m [GIT BRANCH:> $branch >> $url]\033[0m"
#   elif [ -d .hg ]; then
#     hg="$(hg branch 2>/dev/null)" || true
#     fmt="\033[32;1m%u@%h\033[0m:\033[34;1m%w\033[0m\033[33;1m [HG BRANCH:> $hg]\033[0m"
#   elif [ -d .svn ]; then
#     svn="$(svn info 2>/dev/null | awk '/^URL: /{print $2}')" || true
#     fmt="\033[32;1m%u@%h\033[0m:\033[34;1m%w\033[0m\033[33;1m [SVN URL:> $svn]\033[0m"
#   else
#     fmt="\033[32;1m%u@%h\033[0m:\033[34;1m%d\033[0m\033[1m%f\033[0m"
#   fi
#   lf -remote "send $id set promptfmt \"$fmt\""
# }}

# dynamic panes
cmd on-init :{{
  cmd on-redraw %{{
    if [ "$lf_width" -le 100 ]; then
      lf -remote "send $id set ratios 1:1"
    elif [ "$lf_width" -le 180 ]; then
      lf -remote "send $id set ratios 1:2:3"
    fi
  }}

  on-redraw
}}

# toggle preview pane
cmd toggle-preview %{{
    if [ "$lf_preview" = true ]; then
        lf -remote "send $id :set preview false; set ratios 1:1"
    else
        lf -remote "send $id :set preview true; set ratios 1:2:3"
    fi
}}

# toggle hex preview
cmd toggle_hex_view &{{
    # reload is used to clear any previews that have been cached
    if [ "$lf_user_hex_view" != true ]; then
        lf -remote "send $id :set user_hex_view true; reload"
    else
        lf -remote "send $id :set user_hex_view false; reload"
    fi
}}

map ,pp toggle-preview
map ,px toggle_hex_view

# select by type
cmd select-type &{{
    set -f
    [ "$#" -eq 0 ] && exit
    files="$(
        find "$PWD" -mindepth 1 -maxdepth 1 -type "$1" $([ "$lf_hidden" = false ] && printf '%s\n' -not -name '.*') -print0 |
        sed -z 's/\\/\\\\/g;s/"/\\"/g;s/\n/\\n/g;s/^/"/;s/$/"/' |
        tr '\0' ' ')"

    lf -remote "send $id :unselect; toggle $files"
}}

cmd select-dirs select-type d
cmd select-files select-type f

# recursive glob-select
# For example, run :select-glob **/*.txt to select all .txt files recursively.
cmd select-glob &{{
    select_glob() {
        files="$(printf '%s\0' "$@" | sed 's/ /\\ /g;s/\x00/ /g')"
        lf -remote "send $id :unselect; toggle $files"
    }

    [ "$#" -eq 1 ] || exit

    # recursive glob and failglob are not supported in POSIX sh
    select_glob $1
}}
# bash
# cmd select-glob &{{
#     select_glob() {
#         files="$(printf '%s\0' "$@" | sed 's/ /\\ /g;s/\x00/ /g')"
#         lf -remote "send $id :unselect; toggle $files"
#     }
# 
#     [ "$#" -eq 1 ] || exit
# 
#     # enable recursive glob and failglob
#     shopt -s globstar failglob
# 
#     select_glob $1
# }}
# zsh
#     select_glob() {
#         files="$(printf '%s\0' "$@" | sed 's/ /\\ /g;s/\x00/ /g')"
#         lf -remote "send $id :unselect; toggle $files"
#     }
# 
#     [ "$#" -eq 1 ] || exit
# 
#     # recursive glob and failglob are enabled by default in zsh
# 
#     # use `$~1` instead of `$1` to expand glob
#     select_glob $~1
# }}

# incfilter select and open
# set incfilter
# 
# map f filter
# 
# cmap <enter> &{{
#     # select and open file
#     if [ "$lf_mode" = filter ]; then
#         lf -remote "send $id :cmd-enter; setfilter; open"
#     else
#         lf -remote "send $id cmd-enter"
#     fi
# }}
# 
# cmap <a-n> &{{
#     # go to next file
#     if [ "$lf_mode" = filter ]; then
#         lf -remote "send $id down"
#     fi
# }}
# 
# cmap <a-p> &{{
#     # go to previous file
#     if [ "$lf_mode" = filter ]; then
#         lf -remote "send $id up"
#     fi
# }}


